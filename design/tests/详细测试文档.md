# 高校宿舍管理系统 - 详细测试文档

## 目录
1. [概述](#概述)
2. [测试环境](#测试环境)
3. [功能模块说明](#功能模块说明)
4. [测试策略](#测试策略)
5. [黑盒测试用例](#黑盒测试用例)
6. [白盒测试用例](#白盒测试用例)
7. [异常处理用例](#异常处理用例)
8. [测试驱动与桩模块](#测试驱动与桩模块)
9. [集成测试](#集成测试)
10. [测试执行](#测试执行)

---

## 概述

本文档详细说明了高校宿舍管理系统的软件测试方案，包含两个主要功能模块的单元测试、集成测试及异常测试。

**主要功能模块：**
1. **调宿管理模块（AdjustRoom）** - 负责学生宿舍调换申请的管理
2. **报修管理模块（Repair）** - 负责宿舍报修单的管理

**测试范围：** 按照实验要求，采用黑盒测试为主、白盒测试为辅的方法，包括正常流程、边界条件、异常处理等全面测试。

---

## 测试环境

| 项目 | 说明 |
|------|------|
| **JDK 版本** | 1.8+ (建议 11 或以上) |
| **Build Tool** | Maven 3.6+ |
| **Test Framework** | JUnit 5 (Jupiter) |
| **Mock Framework** | Mockito 4.0+ |
| **Application Framework** | Spring Boot 2.6.3 |
| **ORM Framework** | MyBatis Plus 3.5.1 |
| **数据库** | MySQL 5.7+ (用于集成测试时需要配置) |

**依赖配置示例：**
```xml
<!-- 测试框架 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-test</artifactId>
    <scope>test</scope>
</dependency>

<!-- Mockito（已通过 spring-boot-starter-test 引入）-->
<dependency>
    <groupId>org.mockito</groupId>
    <artifactId>mockito-core</artifactId>
    <scope>test</scope>
</dependency>
```

---

## 功能模块说明

### 模块 1：调宿管理模块 (AdjustRoom)

**功能说明：**
学生提交调宿申请，由宿管员审核并安排具体调换方案。

**核心类：**
- **Entity:** `com.example.springboot.entity.AdjustRoom`
- **Service:** `com.example.springboot.service.impl.AdjustRoomServiceImpl`
- **Mapper:** `com.example.springboot.mapper.AdjustRoomMapper`

**主要业务方法：**
```java
// 1. 添加调宿申请
public int addApply(AdjustRoom adjustRoom)

// 2. 查询调宿申请（分页）
public Page find(Integer pageNum, Integer pageSize, String search)

// 3. 删除调宿申请
public int deleteAdjustment(Integer id)

// 4. 更新调宿申请状态
public int updateApply(AdjustRoom adjustRoom)
```

**关键字段：**
- `id` - 申请ID（自增主键）
- `username` - 申请学生用户名
- `name` - 申请学生姓名
- `currentRoomId` - 当前宿舍ID
- `currentBedId` - 当前床位ID
- `towardsRoomId` - 目标宿舍ID
- `towardsBedId` - 目标床位ID
- `state` - 申请状态（待审批/已通过/已拒绝/已完成）
- `applyTime` - 申请时间
- `finishTime` - 完成时间

---

### 模块 2：报修管理模块 (Repair)

**功能说明：**
学生报告宿舍故障，宿管员接收并安排维修。

**核心类：**
- **Entity:** `com.example.springboot.entity.Repair`
- **Service:** `com.example.springboot.service.impl.RepairServiceImpl`
- **Mapper:** `com.example.springboot.mapper.RepairMapper`

**主要业务方法：**
```java
// 1. 添加报修单
public int addNewOrder(Repair repair)

// 2. 查询报修单（分页）
public Page find(Integer pageNum, Integer pageSize, String search)

// 3. 个人查询报修单
public Page individualFind(Integer pageNum, Integer pageSize, String search, String name)

// 4. 更新报修单
public int updateNewOrder(Repair repair)

// 5. 删除报修单
public int deleteOrder(Integer id)

// 6. 显示报修统计
public int showOrderNum()
```

**关键字段：**
- `id` - 报修单ID（自增主键）
- `repairer` - 报修人
- `dormBuildId` - 宿舍楼ID
- `dormRoomId` - 宿舍房间ID
- `title` - 报修标题（如"漏水"、"门坏了"等）
- `content` - 报修详细内容
- `state` - 报修状态（待处理/处理中/已完成）
- `orderBuildTime` - 报修单建立时间
- `orderFinishTime` - 报修单完成时间

---

## 测试策略

### 1. 测试方法

按照实验要求，采用分层测试策略：

#### 1.1 黑盒测试（主要方法）
- 基于功能需求规格说明书
- **不关心内部实现逻辑**，仅验证输入输出
- 重点测试：正常功能流程、边界条件、异常处理
- 用例设计基于等价类和边界值分析

#### 1.2 白盒测试（辅助方法）
- **重点测试重要执行路径**
- 分析源代码的控制流和数据流
- 先列出所有判定和条件
- 根据不同覆盖标准设计测试用例
  - 语句覆盖（Statement Coverage）
  - 分支覆盖（Branch Coverage）
  - 路径覆盖（Path Coverage）

### 2. 覆盖标准

根据不同的覆盖标准设计测试用例：

| 覆盖类型 | 说明 | 用例数量 |
|---------|------|---------|
| **语句覆盖** | 保证每条语句至少被执行一次 | 基础 |
| **分支覆盖** | 保证每个条件分支都被测试（if-else所有分支） | 基础+条件 |
| **路径覆盖** | 保证所有可能的执行路径都被测试 | 全面 |

---

## 黑盒测试用例

### 黑盒测试 - 调宿管理模块 (AdjustRoom)

#### 测试用例 1：添加调宿申请 - 正常情况

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-AR-001 |
| **测试类名** | AdjustRoomServiceImplTest |
| **测试方法** | addApply_success() |
| **功能描述** | 测试成功添加调宿申请 |
| **前置条件** | AdjustRoom对象已正确构建，Mapper返回1（表示插入成功） |
| **输入数据** | 构造一个完整的AdjustRoom对象：username="stu1", name="张三", currentRoomId=101, ... |
| **预期输出** | addApply()方法返回1 |
| **验证方式** | assertEquals(1, res) 和 verify调用次数 |

**代码示例：**
```java
@Test
void addApply_success() {
    // 1. 构造测试数据
    AdjustRoom adj = new AdjustRoom();
    adj.setUsername("stu1");
    adj.setName("张三");
    adj.setCurrentRoomId(101);
    adj.setCurrentBedId(1);
    adj.setTowardsRoomId(201);
    adj.setTowardsBedId(2);
    adj.setState("待审批");
    adj.setApplyTime("2025-11-25");

    // 2. 设置Mapper桩行为：返回1表示插入成功
    when(adjustRoomMapper.insert(any(AdjustRoom.class))).thenReturn(1);

    // 3. 执行被测试方法
    int res = adjustRoomService.addApply(adj);

    // 4. 验证结果
    assertEquals(1, res);  // 返回值应为1
    verify(adjustRoomMapper, times(1)).insert(adj);  // 确保调用了一次insert
}
```

---

#### 测试用例 2：查询调宿申请 - 分页查询

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-AR-002 |
| **测试方法** | find_returnsPage() |
| **功能描述** | 测试分页查询调宿申请列表 |
| **前置条件** | 数据库中存在若干调宿申请记录 |
| **输入数据** | pageNum=1, pageSize=10, search="stu" |
| **预期输出** | 返回一个Page对象，包含符合条件的记录 |
| **验证方式** | Page对象不为null，验证selectPage被调用一次 |

**代码示例：**
```java
@Test
void find_returnsPage() {
    // 1. 构造返回值Page对象
    Page<AdjustRoom> page = new Page<>(1, 10);
    
    // 2. 设置Mapper的桩行为
    when(adjustRoomMapper.selectPage(any(Page.class), any())).thenReturn(page);

    // 3. 执行被测试方法
    Page<?> result = adjustRoomService.find(1, 10, "stu");

    // 4. 验证结果
    assertNotNull(result);  // 结果不为null
    assertEquals(1, result.getCurrent());  // 当前页数应为1
    assertEquals(10, result.getSize());  // 每页大小应为10
    verify(adjustRoomMapper, times(1)).selectPage(any(Page.class), any());
}
```

---

#### 测试用例 3：删除调宿申请 - 正常删除

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-AR-003 |
| **测试方法** | deleteAdjustment_success() |
| **功能描述** | 测试成功删除存在的调宿申请 |
| **前置条件** | 数据库中存在ID=1的调宿申请记录 |
| **输入数据** | id=1 |
| **预期输出** | 返回1（表示删除成功） |
| **验证方式** | assertEquals(1, res) |

**代码示例：**
```java
@Test
void deleteAdjustment_success() {
    when(adjustRoomMapper.deleteById(1)).thenReturn(1);
    
    int res = adjustRoomService.deleteAdjustment(1);
    
    assertEquals(1, res);
    verify(adjustRoomMapper, times(1)).deleteById(1);
}
```

---

#### 测试用例 4：删除调宿申请 - 删除不存在的记录

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-AR-004 |
| **测试方法** | deleteAdjustment_nonExisting_returnsZero() |
| **功能描述** | 测试删除不存在的调宿申请（边界条件） |
| **前置条件** | 数据库中不存在ID=999的记录 |
| **输入数据** | id=999 |
| **预期输出** | 返回0（表示没有删除任何记录） |
| **验证方式** | assertEquals(0, res) |

**代码示例：**
```java
@Test
void deleteAdjustment_nonExisting_returnsZero() {
    // 设置Mapper返回0表示没有删除任何行
    when(adjustRoomMapper.deleteById(999)).thenReturn(0);
    
    int res = adjustRoomService.deleteAdjustment(999);
    
    assertEquals(0, res);  // 应返回0
    verify(adjustRoomMapper, times(1)).deleteById(999);
}
```

---

#### 测试用例 5：更新调宿申请

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-AR-005 |
| **测试方法** | updateApply_success() |
| **功能描述** | 测试更新调宿申请状态 |
| **前置条件** | 数据库中存在该调宿申请，Mapper返回1 |
| **输入数据** | 构造修改后的AdjustRoom对象：id=1, state="已通过", finishTime="2025-11-25" |
| **预期输出** | 返回1（表示更新成功） |
| **验证方式** | assertEquals(1, res) |

**代码示例：**
```java
@Test
void updateApply_success() {
    AdjustRoom adj = new AdjustRoom();
    adj.setId(1);
    adj.setState("已通过");
    adj.setFinishTime("2025-11-25");
    
    when(adjustRoomMapper.updateById(adj)).thenReturn(1);
    
    int res = adjustRoomService.updateApply(adj);
    
    assertEquals(1, res);
    verify(adjustRoomMapper, times(1)).updateById(adj);
}
```

---

### 黑盒测试 - 报修管理模块 (Repair)

#### 测试用例 6：添加报修单 - 正常情况

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-RP-001 |
| **测试类名** | RepairServiceImplTest |
| **测试方法** | addNewOrder_success() |
| **功能描述** | 测试成功添加报修单 |
| **前置条件** | Repair对象已正确构建 |
| **输入数据** | 构造Repair对象：title="漏水", content="宿舍屋顶严重漏水", repairer="学生A" |
| **预期输出** | 返回1（表示插入成功） |
| **验证方式** | assertEquals(1, res) |

**代码示例：**
```java
@Test
void addNewOrder_success() {
    Repair r = new Repair();
    r.setRepairer("学生A");
    r.setDormBuildId(1);
    r.setDormRoomId(101);
    r.setTitle("漏水");
    r.setContent("宿舍屋顶严重漏水");
    r.setState("待处理");
    r.setOrderBuildTime("2025-11-25");
    
    when(repairMapper.insert(any(Repair.class))).thenReturn(1);
    
    int res = repairService.addNewOrder(r);
    
    assertEquals(1, res);
    verify(repairMapper, times(1)).insert(r);
}
```

---

#### 测试用例 7：删除报修单 - 正常删除

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-RP-002 |
| **测试方法** | deleteOrder_success() |
| **功能描述** | 测试成功删除存在的报修单 |
| **前置条件** | 数据库中存在ID=1的报修单 |
| **输入数据** | id=1 |
| **预期输出** | 返回1（表示删除成功） |
| **验证方式** | assertEquals(1, res) |

**代码示例：**
```java
@Test
void deleteOrder_success() {
    when(repairMapper.deleteById(1)).thenReturn(1);
    
    int res = repairService.deleteOrder(1);
    
    assertEquals(1, res);
    verify(repairMapper, times(1)).deleteById(1);
}
```

---

#### 测试用例 8：删除报修单 - 记录不存在

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-RP-003 |
| **测试方法** | deleteOrder_notFound_returnsZero() |
| **功能描述** | 测试删除不存在的报修单 |
| **前置条件** | 数据库中不存在ID=999的报修单 |
| **输入数据** | id=999 |
| **预期输出** | 返回0（表示没有删除任何记录） |
| **验证方式** | assertEquals(0, res) |

**代码示例：**
```java
@Test
void deleteOrder_notFound_returnsZero() {
    when(repairMapper.deleteById(999)).thenReturn(0);
    
    int res = repairService.deleteOrder(999);
    
    assertEquals(0, res);
    verify(repairMapper, times(1)).deleteById(999);
}
```

---

## 白盒测试用例

### 白盒测试原理

白盒测试基于源代码的内部结构，通过分析以下内容设计测试用例：

1. **所有判定/条件** - 识别代码中的所有if-else、switch-case等分支
2. **覆盖标准选择** - 选择合适的覆盖标准
3. **测试用例生成** - 根据覆盖标准生成测试用例

### 白盒测试 - 调宿管理模块

#### 源代码分析

```java
// find()方法的源代码分析
public Page find(Integer pageNum, Integer pageSize, String search) {
    Page page = new Page<>(pageNum, pageSize);  // 判定1: 参数是否为null
    QueryWrapper<AdjustRoom> qw = new QueryWrapper<>();
    qw.like("username", search);  // 判定2: search是否为空串或null
    Page orderPage = adjustRoomMapper.selectPage(page, qw);
    return orderPage;  // 判定3: orderPage是否为null
}
```

#### 所有判定列表

| 判定编号 | 判定描述 | 条件 | 需要覆盖 |
|---------|--------|------|---------|
| J1 | pageNum是否为null | pageNum == null | True/False |
| J2 | pageSize是否为null | pageSize == null | True/False |
| J3 | search是否为null或空 | search == null \|\| search.isEmpty() | True/False |
| J4 | 查询结果是否为null | orderPage == null | True/False |

#### 白盒测试用例 1：语句覆盖

**测试目标：** 使代码中的每条语句至少执行一次

| 用例编号 | 输入参数 | 预期结果 | 覆盖内容 |
|---------|--------|--------|---------|
| TC-WB-AR-001 | pageNum=1, pageSize=10, search="stu" | 返回非null的Page对象 | 覆盖正常执行路径 |

---

#### 白盒测试用例 2：分支覆盖

**测试目标：** 使代码中的所有条件分支都被执行

| 用例编号 | 输入参数 | 预期结果 | 分支覆盖 |
|---------|--------|--------|---------|
| TC-WB-AR-002 | pageNum=1, pageSize=10, search="stu" | 返回Page对象 | True分支 |
| TC-WB-AR-003 | pageNum=null, pageSize=10, search="stu" | 抛出NullPointerException或处理null | False分支(pageNum) |
| TC-WB-AR-004 | pageNum=1, pageSize=null, search="stu" | 抛出NullPointerException或处理null | False分支(pageSize) |
| TC-WB-AR-005 | pageNum=1, pageSize=10, search="" | 返回空的Page对象或正确处理 | False分支(search) |
| TC-WB-AR-006 | pageNum=0, pageSize=0, search="stu" | 返回Page对象或异常 | 边界值测试 |

---

#### 白盒测试用例 3：路径覆盖

**测试目标：** 覆盖所有可能的执行路径

列举所有可能的路径组合（2^4 = 16种）：

| 路径ID | J1(pageNum) | J2(pageSize) | J3(search) | J4(result) | 用例编号 |
|-------|------------|------------|----------|----------|---------|
| P1 | T | T | T | T | TC-WB-AR-007 |
| P2 | T | T | T | F | TC-WB-AR-008 |
| P3 | T | T | F | T | TC-WB-AR-009 |
| P4 | T | T | F | F | TC-WB-AR-010 |
| P5 | T | F | T | T | TC-WB-AR-011 |
| ... | ... | ... | ... | ... | ... |

**简化示例（关键路径）：**

```java
// 路径1：正常路径 (T-T-T-T)
@Test
void find_normalPath_returnsNonNullPage() {
    Page<AdjustRoom> expectedPage = new Page<>(1, 10);
    when(adjustRoomMapper.selectPage(any(Page.class), any())).thenReturn(expectedPage);
    
    Page<?> result = adjustRoomService.find(1, 10, "stu");
    
    assertNotNull(result);
}

// 路径2：search为空 (T-T-F-T)
@Test
void find_emptySearch_returnsPage() {
    Page<AdjustRoom> expectedPage = new Page<>(1, 10);
    when(adjustRoomMapper.selectPage(any(Page.class), any())).thenReturn(expectedPage);
    
    Page<?> result = adjustRoomService.find(1, 10, "");
    
    assertNotNull(result);
}

// 路径3：pageNum为null (F-T-T-T)
@Test
void find_nullPageNum_throwsException() {
    assertThrows(NullPointerException.class, () -> {
        adjustRoomService.find(null, 10, "stu");
    });
}
```

---

### 白盒测试 - 报修管理模块

#### 关键方法分析：updateNewOrder()

```java
public int updateNewOrder(Repair repair) {
    // 判定1: repair是否为null
    if (repair == null) {
        return 0;  // 或抛异常
    }
    // 判定2: repair.id是否为null或无效
    if (repair.getId() == null || repair.getId() <= 0) {
        return 0;
    }
    int i = repairMapper.updateById(repair);  // 判定3: 更新结果
    return i;  // 返回0或正数
}
```

#### 白盒测试用例

| 用例编号 | 测试方法 | 输入数据 | 判定条件 | 预期结果 |
|---------|--------|--------|---------|--------|
| TC-WB-RP-001 | updateNewOrder_validRepair | id=1, title="固定" | repair!=null && id>0 | 返回1(成功) |
| TC-WB-RP-002 | updateNewOrder_nullRepair | null | repair==null | 返回0(失败) |
| TC-WB-RP-003 | updateNewOrder_invalidId | id=null | id==null | 返回0(失败) |
| TC-WB-RP-004 | updateNewOrder_zeroId | id=0 | id<=0 | 返回0(失败) |
| TC-WB-RP-005 | updateNewOrder_negativeId | id=-1 | id<=0 | 返回0(失败) |

---

## 异常处理用例

### 异常处理用例 - 调宿管理模块

#### 异常用例 1：数据库异常 - Mapper抛异常

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-EX-AR-001 |
| **异常类型** | RuntimeException (数据库连接失败) |
| **测试方法** | addApply_mapperThrows_exceptionPropagated() |
| **功能描述** | 测试Service层是否正确处理Mapper异常 |
| **前置条件** | Mapper.insert()抛出RuntimeException |
| **输入数据** | 任意有效的AdjustRoom对象 |
| **预期行为** | Service层应将异常向上抛出（不吞掉异常） |

**代码示例：**
```java
@Test
void addApply_mapperThrows_exceptionPropagated() {
    AdjustRoom adj = new AdjustRoom();
    
    // 设置Mapper抛出异常
    when(adjustRoomMapper.insert(any(AdjustRoom.class)))
        .thenThrow(new RuntimeException("数据库连接失败"));

    // 验证异常被正确抛出
    RuntimeException ex = assertThrows(RuntimeException.class, () -> 
        adjustRoomService.addApply(adj)
    );
    
    // 验证异常信息
    assertTrue(ex.getMessage().contains("数据库连接失败"));
    verify(adjustRoomMapper, times(1)).insert(adj);
}
```

---

#### 异常用例 2：参数验证 - 必填字段为null

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-EX-AR-002 |
| **异常类型** | NullPointerException 或 IllegalArgumentException |
| **测试方法** | addApply_nullUsername_exceptionThrown() |
| **功能描述** | 测试必填字段为null时的处理 |
| **前置条件** | AdjustRoom对象username字段为null |
| **输入数据** | username=null的AdjustRoom对象 |
| **预期行为** | 抛出异常或返回失败标识 |

**代码示例：**
```java
@Test
void addApply_nullUsername_exceptionThrown() {
    AdjustRoom adj = new AdjustRoom();
    adj.setUsername(null);  // 必填字段为null
    
    // 方案1：验证异常
    assertThrows(Exception.class, () -> 
        adjustRoomService.addApply(adj)
    );
    
    // 方案2：如果service返回0表示失败
    // when(adjustRoomMapper.insert(any())).thenReturn(0);
    // int res = adjustRoomService.addApply(adj);
    // assertEquals(0, res);
}
```

---

#### 异常用例 3：分页参数异常 - 负数页码

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-EX-AR-003 |
| **异常类型** | IllegalArgumentException 或返回空页 |
| **测试方法** | find_negativePageNum_exceptionOrEmpty() |
| **功能描述** | 测试非法的分页参数 |
| **前置条件** | pageNum<0或pageSize<1 |
| **输入数据** | pageNum=-1, pageSize=10 |
| **预期行为** | 抛出异常或返回空的Page对象 |

**代码示例：**
```java
@Test
void find_negativePageNum_exceptionOrEmpty() {
    // 方案1：验证异常
    assertThrows(Exception.class, () -> 
        adjustRoomService.find(-1, 10, "stu")
    );
    
    // 方案2：返回空页
    // Page<AdjustRoom> emptyPage = new Page<>(1, 10);
    // when(adjustRoomMapper.selectPage(any(), any())).thenReturn(emptyPage);
    // Page<?> result = adjustRoomService.find(-1, 10, "stu");
    // assertEquals(0, result.getTotal());
}
```

---

#### 异常用例 4：并发访问异常 - 脏读/死锁

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-EX-AR-004 |
| **异常类型** | Deadlock异常 或 Transaction异常 |
| **测试方法** | addApply_concurrentAccess_transactionRollback() |
| **功能描述** | 测试@Transactional的回滚机制 |
| **前置条件** | 多线程并发更新同一记录 |
| **预期行为** | 事务正确回滚，数据一致 |

**代码示例：**
```java
@Test
void addApply_transactionRollback_onException() {
    AdjustRoom adj1 = new AdjustRoom();
    adj1.setUsername("stu1");
    
    AdjustRoom adj2 = new AdjustRoom();
    adj2.setUsername("stu1");  // 可能违反唯一约束
    
    // 第一次成功
    when(adjustRoomMapper.insert(any())).thenReturn(1);
    int res1 = adjustRoomService.addApply(adj1);
    assertEquals(1, res1);
    
    // 第二次插入相同用户，模拟事务回滚
    when(adjustRoomMapper.insert(any()))
        .thenThrow(new RuntimeException("唯一约束冲突"));
    
    assertThrows(RuntimeException.class, () -> 
        adjustRoomService.addApply(adj2)
    );
}
```

---

### 异常处理用例 - 报修管理模块

#### 异常用例 5：Mapper异常

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-EX-RP-001 |
| **异常类型** | SQLException, RuntimeException |
| **测试方法** | addNewOrder_mapperThrows_exceptionPropagated() |
| **功能描述** | 测试报修单添加时的Mapper异常处理 |
| **前置条件** | Mapper.insert()抛出异常 |
| **预期行为** | 异常向上传播 |

**代码示例：**
```java
@Test
void addNewOrder_mapperThrows_exceptionPropagated() {
    Repair r = new Repair();
    r.setTitle("漏水");
    
    when(repairMapper.insert(any(Repair.class)))
        .thenThrow(new RuntimeException("SQL执行错误"));

    RuntimeException ex = assertThrows(RuntimeException.class, () -> 
        repairService.addNewOrder(r)
    );
    
    assertTrue(ex.getMessage().contains("SQL执行错误"));
}
```

---

#### 异常用例 6：数据不一致

| 项目 | 内容 |
|------|------|
| **用例编号** | TC-EX-RP-002 |
| **异常类型** | DataIntegrityViolationException |
| **测试方法** | addNewOrder_invalidForeignKey_exceptionThrown() |
| **功能描述** | 测试外键约束异常 |
| **前置条件** | dormBuildId或dormRoomId引用不存在的记录 |
| **预期行为** | 抛出数据完整性异常 |

**代码示例：**
```java
@Test
void addNewOrder_invalidForeignKey_exceptionThrown() {
    Repair r = new Repair();
    r.setDormBuildId(9999);  // 不存在的建筑ID
    r.setDormRoomId(9999);   // 不存在的房间ID
    r.setTitle("测试");
    
    when(repairMapper.insert(any(Repair.class)))
        .thenThrow(new RuntimeException("外键约束失败"));

    assertThrows(RuntimeException.class, () -> 
        repairService.addNewOrder(r)
    );
}
```

---

## 测试驱动与桩模块

### 1. 单元测试中的Mockito桩

#### 1.1 桩的作用

- **隔离被测试对象** - 单元测试只测试Service层，不涉及数据库
- **控制外部依赖行为** - 通过桩精确控制Mapper的返回值
- **提高测试执行速度** - 避免真实数据库操作
- **便于测试异常情况** - 可以让Mapper抛出任意异常

#### 1.2 Mockito桩的用法

**基本语法：**
```java
// 1. 声明桩
@Mock
private AdjustRoomMapper adjustRoomMapper;

// 2. 初始化桩
@BeforeEach
void setUp() {
    MockitoAnnotations.openMocks(this);
}

// 3. 配置桩行为 - 返回值
when(adjustRoomMapper.insert(any(AdjustRoom.class))).thenReturn(1);

// 4. 配置桩行为 - 异常
when(adjustRoomMapper.insert(any())).thenThrow(new RuntimeException("Error"));

// 5. 验证桩被正确调用
verify(adjustRoomMapper, times(1)).insert(any());
```

#### 1.3 AdjustRoomMapper桩配置示例

```java
// 文件: AdjustRoomServiceImplTest.java
package com.example.springboot.service.impl;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.example.springboot.entity.AdjustRoom;
import com.example.springboot.mapper.AdjustRoomMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class AdjustRoomServiceImplTest {

    // 声明Mapper桩
    @Mock
    private AdjustRoomMapper adjustRoomMapper;

    // 注入被测试的Service
    // @InjectMocks会自动将@Mock的依赖注入到Service中
    @InjectMocks
    private AdjustRoomServiceImpl adjustRoomService;

    // 初始化
    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    // 测试用例...
}
```

#### 1.4 RepairMapper桩配置示例

```java
// 文件: RepairServiceImplTest.java
package com.example.springboot.service.impl;

import com.example.springboot.entity.Repair;
import com.example.springboot.mapper.RepairMapper;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

class RepairServiceImplTest {

    @Mock
    private RepairMapper repairMapper;

    @InjectMocks
    private RepairServiceImpl repairService;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    // 测试用例...
}
```

---

### 2. 集成测试中的Spring桩

#### 2.1 Spring桩与Mockito桩的区别

| 特性 | Mockito桩 | Spring @MockBean桩 |
|------|---------|------------------|
| **作用范围** | 单个对象 | 整个Spring上下文 |
| **测试类型** | 单元测试 | 集成测试 |
| **依赖注入** | @InjectMocks | Spring容器自动注入 |
| **Spring支持** | 不需要 | 需要@SpringBootTest |
| **性能** | 快速 | 较慢（启动Spring） |
| **用途** | 隔离Service | 验证Spring装配 |

#### 2.2 集成测试示例

```java
// 文件: AdjustRoomServiceIntegrationTest.java
package com.example.springboot.service;

import com.baomidou.mybatisplus.extension.plugins.pagination.Page;
import com.example.springboot.entity.AdjustRoom;
import com.example.springboot.mapper.AdjustRoomMapper;
import com.example.springboot.service.impl.AdjustRoomServiceImpl;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.boot.test.mock.mockito.MockBean;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.when;

@SpringBootTest  // 启动完整的Spring上下文
class AdjustRoomServiceIntegrationTest {

    // 自动装配Service（来自Spring容器）
    @Autowired
    private AdjustRoomServiceImpl adjustRoomService;

    // 将Mapper替换为Spring桩（@MockBean）
    @MockBean
    private AdjustRoomMapper adjustRoomMapper;

    @Test
    void testServiceWiring() {
        // 验证Service被正确装配
        assertNotNull(adjustRoomService);
    }

    @Test
    void addApply_integrationTest() {
        AdjustRoom adj = new AdjustRoom();
        adj.setUsername("stu1");
        
        // 配置Spring桩行为
        when(adjustRoomMapper.insert(any(AdjustRoom.class))).thenReturn(1);

        int res = adjustRoomService.addApply(adj);

        assertEquals(1, res);
    }

    @Test
    void find_integrationTest() {
        Page<AdjustRoom> mockPage = new Page<>(1, 10);
        when(adjustRoomMapper.selectPage(any(Page.class), any())).thenReturn(mockPage);

        Page<?> result = adjustRoomService.find(1, 10, "stu");

        assertNotNull(result);
        assertEquals(1, result.getCurrent());
    }
}
```

---

### 3. 驱动模块与桩模块的位置

| 类型 | 类名 | 路径 | 说明 |
|------|------|------|------|
| **桩** | AdjustRoomMapper | src/test/java/.../mapper/ (Mockito) | 模拟数据库访问层 |
| **驱动** | AdjustRoomServiceImplTest | src/test/java/.../service/impl/ | 单元测试驱动 |
| **驱动** | AdjustRoomServiceIntegrationTest | src/test/java/.../service/ | 集成测试驱动 |
| **桩** | RepairMapper | src/test/java/.../mapper/ (Mockito) | 模拟报修数据访问 |
| **驱动** | RepairServiceImplTest | src/test/java/.../service/impl/ | 报修单元测试 |

---

## 集成测试

### 1. 集成测试的目标

- **验证Spring上下文装配** - 确保Bean正确注入
- **验证Service与Mapper交互** - 验证调用关系
- **验证事务管理** - @Transactional是否生效
- **验证业务流程** - 多个Service配合是否正常

### 2. 集成测试场景

#### 场景 1：调宿申请完整流程

```java
@SpringBootTest
class AdjustRoomIntegrationScenarioTest {

    @Autowired
    private AdjustRoomService adjustRoomService;

    @MockBean
    private AdjustRoomMapper adjustRoomMapper;

    @Test
    void completeAdjustRoomWorkflow() {
        // 步骤1: 提交申请
        AdjustRoom adj = new AdjustRoom();
        adj.setUsername("stu1");
        adj.setName("张三");
        adj.setCurrentRoomId(101);
        adj.setCurrentBedId(1);
        adj.setTowardsRoomId(201);
        adj.setTowardsBedId(2);
        adj.setState("待审批");
        adj.setApplyTime("2025-11-25");

        when(adjustRoomMapper.insert(any())).thenReturn(1);
        int addResult = adjustRoomService.addApply(adj);
        assertEquals(1, addResult);

        // 步骤2: 宿管审核通过
        adj.setId(1);
        adj.setState("已通过");
        adj.setFinishTime("2025-11-25");

        when(adjustRoomMapper.updateById(any())).thenReturn(1);
        int updateResult = adjustRoomService.updateApply(adj);
        assertEquals(1, updateResult);

        // 步骤3: 查询申请状态
        Page<AdjustRoom> mockPage = new Page<>(1, 10);
        when(adjustRoomMapper.selectPage(any(), any())).thenReturn(mockPage);
        Page<?> queryResult = adjustRoomService.find(1, 10, "stu1");
        assertNotNull(queryResult);

        // 步骤4: 流程完成后删除申请
        when(adjustRoomMapper.deleteById(1)).thenReturn(1);
        int deleteResult = adjustRoomService.deleteAdjustment(1);
        assertEquals(1, deleteResult);
    }
}
```

#### 场景 2：报修管理流程

```java
@SpringBootTest
class RepairIntegrationScenarioTest {

    @Autowired
    private RepairService repairService;

    @MockBean
    private RepairMapper repairMapper;

    @Test
    void completeRepairWorkflow() {
        // 步骤1: 学生提交报修
        Repair repair = new Repair();
        repair.setRepairer("学生A");
        repair.setDormBuildId(1);
        repair.setDormRoomId(101);
        repair.setTitle("漏水");
        repair.setContent("屋顶严重漏水");
        repair.setState("待处理");
        repair.setOrderBuildTime("2025-11-25");

        when(repairMapper.insert(any())).thenReturn(1);
        int addResult = repairService.addNewOrder(repair);
        assertEquals(1, addResult);

        // 步骤2: 宿管更新报修状态
        repair.setId(1);
        repair.setState("处理中");

        when(repairMapper.updateById(any())).thenReturn(1);
        int updateResult = repairService.updateNewOrder(repair);
        assertEquals(1, updateResult);

        // 步骤3: 获取报修统计
        when(repairMapper.selectCount(any())).thenReturn(5L);
        int count = repairService.showOrderNum();
        assertEquals(5, count);

        // 步骤4: 标记完成并删除
        repair.setState("已完成");
        repair.setOrderFinishTime("2025-11-25");

        when(repairMapper.updateById(any())).thenReturn(1);
        repairService.updateNewOrder(repair);

        when(repairMapper.deleteById(1)).thenReturn(1);
        int deleteResult = repairService.deleteOrder(1);
        assertEquals(1, deleteResult);
    }
}
```

---

## 测试执行

### 1. 单个测试用例执行

```bash
# 执行单个测试方法
mvn -Dtest=AdjustRoomServiceImplTest#addApply_success test

# 执行测试类
mvn -Dtest=AdjustRoomServiceImplTest test

# 执行所有测试
mvn test
```

### 2. 生成测试报告

```bash
# 运行测试并生成报告
mvn clean test

# 生成详细的HTML报告（需要配置插件）
mvn surefire-report:report
```

### 3. 覆盖率分析

```bash
# 使用JaCoCo插件生成覆盖率报告
mvn clean test jacoco:report

# 生成的报告位于 target/site/jacoco/index.html
```

---

## 总结

### 测试矩阵

| 模块 | 黑盒测试 | 白盒测试 | 异常测试 | 集成测试 |
|------|--------|--------|--------|---------|
| **AdjustRoom** | 5+ | 5+ | 4+ | 1+ |
| **Repair** | 3+ | 4+ | 2+ | 1+ |
| **总计** | 8+ | 9+ | 6+ | 2+ |

### 覆盖标准

- ✅ 语句覆盖 - 所有语句至少执行一次
- ✅ 分支覆盖 - 所有条件分支都被测试
- ✅ 路径覆盖 - 主要执行路径完全覆盖
- ✅ 异常覆盖 - 关键异常情况都有测试

### 后续改进

1. **参数校验** - 在Service或Controller层添加@Valid注解和自定义验证器
2. **MockMVC测试** - 为Controller层编写集成测试
3. **数据库集成** - 使用H2或TestContainers进行真实数据库测试
4. **性能测试** - 使用JMH进行基准测试
5. **代码覆盖率** - 持续提升单元测试覆盖率到85%+

---

## 附录：测试运行示例

### 运行日志示例

```
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running com.example.springboot.service.impl.AdjustRoomServiceImplTest
[INFO] Tests run: 5, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.456 s - in com.example.springboot.service.impl.AdjustRoomServiceImplTest
[INFO] Running com.example.springboot.service.impl.RepairServiceImplTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.234 s - in com.example.springboot.service.impl.RepairServiceImplTest
[INFO] Running com.example.springboot.service.AdjustRoomServiceIntegrationTest
[INFO] Tests run: 3, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 2.145 s - in com.example.springboot.service.AdjustRoomServiceIntegrationTest
[INFO] 
[INFO] Results:
[INFO] 
[INFO] Tests run: 11, Failures: 0, Errors: 0, Skipped: 0
[INFO] 
[INFO] -------------------------------------------------------
[INFO] BUILD SUCCESS
```

---

**文档版本:** v1.0  
**创建日期:** 2025-11-25  
**最后修改:** 2025-11-25
